1. Donggyu Kim(DK) 437008, donggyukim@wustl.edu, Lab 1

Design implementations were written as comments in each functions that needs explanation.
Common implementation : I created #define OFFSET so that functions can access player names starting from argv[2], and calculate total number of players (argc - OFFSET)


Errors :
The one error was the 'const' was missing in << operators in header file from lab 0. This caused some errors as lab 1 << operator strictly required the use of const in 
function definition.

Warnings :
The use of == to compare strings to do user input check triggered some warning - fixed this by using 'strcmp';

Issues :
So I coded this lab for a while, and when I started coding instructions past #11, I forgot that we created >> operator that passed on a card from one CardSet to the another CardSet.
I manually tried to pop_back and push_back cards, and this caused so many issues with the code as it was not probably moving cards around.

Another issue was that my >> operator was not returning 'reference' to CardSet.
Original code : CardSet<S, R> CardSet<S, R>::operator>>(CardSet<S, R> &card_set);
This created an issue that cards were not properly handed out to each players hand, and took me really long time to figure this out. 
Fixed code : CardSet<S, R> &CardSet<S, R>::operator>>(CardSet<S, R> &card_set)

Another issue was that when I was collecting cards back to the deck, and re-run the game, some cards never left the players hand and stayed there even during the next run.
For example, 
[    a's cards    ]
DA  HK  HQ  H9  C10  
CA  S9  H10  S9  S10  
CK  SK  

[    a's cards    ]
DA  HK  HQ  H9  C10  
CA  SQ  SK  D10  S10  
H9  S9  

Above is a's Cards in Pinochle game, from 2 different game runs. You can see that first 6 cards do not change even after collect() and shuffle().
This happened because of the way I implmented collect() function. My intial collect() function was : 
 for(size_t cardCount = START_COUNT; cardCount < card_set.getCards().size(); cardCount++){
                cout << card_set.getCards().size() << endl;
                card_set >> *this;
            }
As you can see, every time when we >> a card, size() card_set decrement as well(rather than staying as a constant), while cardCount increases, so that for loop does not full iterate through all the cards player had.
I fixed this issue by using while loop.
 while(!card_set.is_empty()){
                   card_set >> *this;
    }

Another issue was that card was never distributed to players. This happened because my >> operator was wrongly implemented.
For example, when I was supposed to move a card from a->b, I was moving a card from b->a. 

Another issue was that after re-running cards, total number of cards doubled every run. This happened because collect() was not properly implemented. 

Other than first error I listed, I did not confront errors much. However, there were so many problems in runtime, as the wrong use of & and incorrect implementations
were hard to find - so I had to check code line as incorrect output was generated by mix of different lines of wrong codes. 